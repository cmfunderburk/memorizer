---
alwaysApply: true
---
# MEMORIZER Codebase Guide

## Overview

MEMORIZER is a single-file Python CLI (~1050 lines) for practicing code recall. Users write solution files in Markdown with fenced code blocks as memorization targets. The tool creates attempt files, launches an editor, and diffs the result.

**Stack**: Python 3.10+ (stdlib only). Optional: `fzf`, `nvim`/`vim`, `less`.

## Architecture

All logic lives in `memorizer.py`. Key data flow:

```
Solution (.md) → parse_markdown() → ParsedMarkdown{blocks, target_blocks}
                                          ↓
                          render_attempt_template() → .attempt.md with [BLOCK N] placeholders
                                          ↓
                              User edits in $EDITOR
                                          ↓
                          parse_markdown(attempt) → compare_blocks() → BlockResult[]
                                          ↓
                          render_markdown_report() → ANSI diff output
```

### Key Types
- `CodeBlock`: Parsed fenced block (language, content, start/end positions, is_target)
- `ParsedMarkdown`: Contains raw_text, all blocks, and target_blocks (excluding `<!-- INFO -->` marked)
- `BlockResult`: Per-block comparison result (accuracy scores, diff_ops, is_perfect)

### Core Functions
| Function | Purpose |
|----------|---------|
| `parse_markdown(text)` | Extract fenced code blocks, respect `<!-- INFO -->` markers |
| `render_attempt_template(parsed)` | Generate attempt file with `[BLOCK N]` placeholders |
| `compare_blocks(expected, actual)` | Per-block diff using `compute_line_diff()` |
| `run_drill(solution_path)` | Main practice loop: parse → edit → compare → retry |
| `get_attempt_history(solution_path)` | Parse stats from `.attempt.md` files |

## Solution File Format

Solutions are Markdown in `solutions/`. Fenced code blocks are targets:

```markdown
# Algorithm Name

**Time:** O(?)  |  **Space:** O(?)

## Implementation

```python
def algorithm():
    pass
```
```

- Multiple code blocks → multiple targets (all must be reproduced)
- `<!-- INFO -->` before a block excludes it from memorization
- Document score = min(block_scores); perfect = all blocks 100%

## Directory Structure

```
memorizer.py              # All application code
solutions/
  focus/                  # Active drill targets (--focus mode)
  new_format/             # Additional solutions
  prospective/            # Legacy format, awaiting conversion to markdown
attempts/                 # Auto-generated .attempt.md files (gitignored)
docs/planning/CURRENT/    # Design documents
```

Note: Files in `prospective/` are in old formats (.py, .c, etc.) and need conversion to `.md` before use.

## Commands

```bash
# Run drill
python3 memorizer.py solutions/focus/merge_sort.md

# Interactive selection
python3 memorizer.py

# Focus mode (random order through solutions/focus/)
python3 memorizer.py --focus

# View history
python3 memorizer.py solutions/focus/merge_sort.md --stats
```

## Testing Without Editor

Use `tee` to simulate editor interaction:

```bash
# Extract code blocks and pipe as "typed" content
python3 -c "
from memorizer import parse_markdown
text = open('solutions/focus/insertion_sort.md').read()
for b in parse_markdown(text).target_blocks:
    print(b.content)
" | EDITOR=/usr/bin/tee python3 memorizer.py solutions/focus/insertion_sort.md
# Exit code 0 = perfect recall
```

## Conventions

- Single-file architecture: all changes go in `memorizer.py`
- ANSI colors via constants (e.g., `ANSI_GREEN`, `ANSI_RED_BG`)
- Path handling: `BASE_DIR`, `SOLUTIONS_ROOT`, `ATTEMPTS_ROOT` constants
- Planning docs go in `docs/planning/CURRENT/`
